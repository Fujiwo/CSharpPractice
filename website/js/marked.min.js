// Simple markdown parser for basic functionality
function parseMarkdown(markdown) {
    let html = markdown;
    
    // Headers
    html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
    html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
    html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
    html = html.replace(/^#### (.*$)/gim, '<h4>$1</h4>');
    
    // Bold
    html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    
    // Italic
    html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
    
    // Code blocks
    html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, function(match, lang, code) {
        const language = lang || 'text';
        return `<pre><code class="language-${language}">${escapeHtml(code.trim())}</code></pre>`;
    });
    
    // Inline code
    html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
    
    // Links
    html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
    
    // Lists
    html = html.replace(/^\s*\* (.+)$/gm, '<li>$1</li>');
    html = html.replace(/^\s*- (.+)$/gm, '<li>$1</li>');
    html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
    
    // Paragraphs
    html = html.split('\n\n').map(paragraph => {
        paragraph = paragraph.trim();
        if (!paragraph) return '';
        if (paragraph.match(/^<[h1-6]|<ul|<ol|<pre|<blockquote/)) {
            return paragraph;
        }
        return `<p>${paragraph}</p>`;
    }).join('\n');
    
    return html;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Simple syntax highlighter for C#
function highlightCSharp(code) {
    // Keywords
    const keywords = [
        'using', 'namespace', 'class', 'public', 'private', 'protected', 'internal',
        'static', 'void', 'int', 'string', 'bool', 'double', 'float', 'char',
        'if', 'else', 'while', 'for', 'foreach', 'do', 'switch', 'case', 'default',
        'try', 'catch', 'finally', 'throw', 'return', 'break', 'continue',
        'new', 'this', 'base', 'override', 'virtual', 'abstract', 'sealed',
        'interface', 'enum', 'struct', 'get', 'set', 'var', 'const', 'readonly',
        'async', 'await', 'Task', 'true', 'false', 'null'
    ];
    
    let highlighted = code;
    
    // Comments
    highlighted = highlighted.replace(/(\/\/.*$)/gm, '<span class="comment">$1</span>');
    highlighted = highlighted.replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="comment">$1</span>');
    
    // Strings
    highlighted = highlighted.replace(/(".*?")/g, '<span class="string">$1</span>');
    
    // Keywords
    keywords.forEach(keyword => {
        const regex = new RegExp(`\\b${keyword}\\b`, 'g');
        highlighted = highlighted.replace(regex, `<span class="keyword">${keyword}</span>`);
    });
    
    // Numbers
    highlighted = highlighted.replace(/\b(\d+(?:\.\d+)?)\b/g, '<span class="number">$1</span>');
    
    // Class names (capitalized words)
    highlighted = highlighted.replace(/\b([A-Z][a-zA-Z0-9]*)\b/g, '<span class="class-name">$1</span>');
    
    return highlighted;
}

// Apply syntax highlighting to all code blocks
function applySyntaxHighlighting() {
    const codeBlocks = document.querySelectorAll('pre code.language-csharp, pre code.language-c#, pre code.language-cs, pre code:not([class])');
    codeBlocks.forEach(block => {
        if (!block.classList.contains('highlighted')) {
            // If no language specified, assume C# for .cs content
            if (!block.className || block.className === '') {
                block.className = 'language-csharp';
            }
            block.innerHTML = highlightCSharp(block.textContent);
            block.classList.add('highlighted');
        }
    });
}